<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Optimisation Simplexe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            margin: auto;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 2rem;
        }

        #input-section {
            background-color: #fff;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 2rem;
            width: 90%;
            max-width: 600px;
        }

        #input-section label {
            display: block;
            margin-bottom: 0.5rem;
            color: #444;
            font-weight: 500;
        }

        #input-section input[type="text"],
        #input-section textarea {
            width: calc(100% - 20px);
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            transition: border-color 0.3s ease;
            font-size: 1rem;
        }

        #input-section input[type="text"]:focus,
        #input-section textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        #input-section textarea {
            resize: vertical;
            min-height: 100px;
        }

        #input-section button {
            padding: 0.75rem 1.5rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-size: 1.1rem;
            width: 100%;
        }

        #input-section button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #input-section button:active {
            background-color: #388e3c;
            transform: translateY(0);
        }

        #result-container {
            background-color: #e3f4f1;
            padding: 1.5rem;
            border-radius: 10px;
            margin-top: 2rem;
            width: 90%;
            max-width: 600px;
            border: 1px solid #b0f0d4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        #result-container h3 {
            color: #1a5235;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        #result-container pre {
            color: #006400;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            font-size: 1rem;
        }

        #graph-container {
            width: 100%;
            max-width: 600px;
            margin-top: 2rem;
        }

        @media (max-width: 768px) {
            #input-section {
                width: 95%;
            }

            #result-container {
                width: 95%;
            }
        }

        @media (max-width: 480px) {
            #input-section button {
                font-size: 1rem;
                padding: 0.75rem 1rem;
            }

            #result-container pre {
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <h1>Optimisation Simplexe</h1>

    <div id="input-section">
        <label for="objective">Fonction à maximiser :</label>
        <input type="text" id="objective" value="4x + 3y + 7z">

        <label for="constraints">Contraintes (<= seulement) :</label>
                <textarea id="constraints" rows="5">x + 2y + z <= 14
3x - y + 2z <= 10
x + 3y + 2z <= 16</textarea>

                <button onclick="solve()">Résoudre</button>
    </div>

    <div id="result-container">
        <h3>Résultat :</h3>
        <pre id="result"></pre>
    </div>

    <div id="graph-container"></div>

    <script>
        function parseExpr(expr) {
            let terms = expr.replace(/\s+/g, '').match(/[+-]?\d*\.?\d*[a-z]/gi);
            let coeffs = {};
            for (let t of terms) {
                let [, coef, varName] = t.match(/([+-]?\d*\.?\d*)([a-z])/);
                coef = coef === '' || coef === '+' ? 1 : coef === '-' ? -1 : parseFloat(coef);
                coeffs[varName] = coef;
            }
            return coeffs;
        }

        function extractVars(objective, constraints) {
            const all = [objective, ...constraints].join('');
            return Array.from(new Set(all.match(/[a-z]/gi))).sort();
        }

        function buildTableau(objective, constraints, vars) {
            let tableau = [], rhs = [];
            let slackIndex = 0;
            for (let line of constraints) {
                let [lhs, b] = line.split('<=').map(x => x.trim());
                let row = vars.map(v => parseExpr(lhs)[v] || 0);
                let slack = Array(constraints.length).fill(0);
                slack[slackIndex++] = 1;
                row = row.concat(slack);
                rhs.push(parseFloat(b));
                tableau.push(row);
            }

            // Objective row
            let objRow = vars.map(v => -(parseExpr(objective)[v] || 0));
            objRow = objRow.concat(Array(constraints.length).fill(0));
            tableau.push(objRow);
            rhs.push(0);
            return { tableau, rhs };
        }

        function pivot(t, rhs, row, col) {
            let pivotVal = t[row][col];
            t[row] = t[row].map(x => x / pivotVal);
            rhs[row] = rhs[row] / pivotVal;

            for (let i = 0; i < t.length; i++) {
                if (i !== row) {
                    let factor = t[i][col];
                    for (let j = 0; j < t[0].length; j++) {
                        t[i][j] -= factor * t[row][j];
                    }
                    rhs[i] -= factor * rhs[row];
                }
            }
        }

        function simplex(tableau, rhs) {
            let cols = tableau[0].length;
            let rows = tableau.length;

            while (true) {
                let last = tableau[rows - 1];
                let entering = last.findIndex(x => x < -1e-8);
                if (entering === -1) break;

                let minRatio = Infinity, pivotRow = -1;
                for (let i = 0; i < rows - 1; i++) {
                    if (tableau[i][entering] > 1e-8) {
                        let ratio = rhs[i] / tableau[i][entering];
                        if (ratio < minRatio) {
                            minRatio = ratio;
                            pivotRow = i;
                        }
                    }
                }
                if (pivotRow === -1) throw "Problème non borné";
                pivot(tableau, rhs, pivotRow, entering);
            }
            return { tableau, rhs };
        }

        function solve() {
            let obj = document.getElementById("objective").value;
            let constraints = document.getElementById("constraints").value.trim().split('\n');
            let result = document.getElementById("result");

            try {
                const vars = extractVars(obj, constraints);
                let { tableau, rhs } = buildTableau(obj, constraints, vars);
                let final = simplex(tableau, rhs);

                let output = "La solution optimale est :\n";
                let values = Array(vars.length).fill(0);
                for (let v = 0; v < vars.length; v++) {
                    let found = false;
                    for (let i = 0; i < final.tableau.length - 1; i++) {
                        let count = 0;
                        for (let j = 0; j < final.tableau[0].length - 1; j++) {
                            if (Math.abs(final.tableau[i][j]) < 1e-8) {
                                count++;
                            } else if (Math.abs(final.tableau[i][j] - 1) < 1e-8 && j === v) {
                                values[v] = final.rhs[i];
                                found = true;
                                break;
                            }
                        }
                        if (found) break;
                    }
                    if (!found) {
                        values[v] = 0;
                    }
                }

                for (let i = 0; i < vars.length; i++) {
                    output += `${vars[i]} = ${values[i].toFixed(4)}\n`;
                }

                let z = final.rhs[final.rhs.length - 1];
                output += `Valeur optimale : ${z.toFixed(4)}`;
                result.textContent = output;

                // Plot the result with constraints
                plotResult(vars, values, z, constraints);

            } catch (err) {
                result.textContent = "Erreur : " + err;
            }
        }

        function plotResult(vars, values, optimalValue, constraints) {
            let graphContainer = document.getElementById("graph-container");
            graphContainer.innerHTML = ''; // Clear previous graph

            let traces = [];
            let colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];

            if (vars.length === 2) {
                // 2D Plot
                let solutionTrace = {
                    x: [values[0]],
                    y: [values[1]],
                    mode: 'markers+text',
                    type: 'scatter',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split('<=').map(x => x.trim());
                    let coeffs = parseExpr(lhs);
                    let xValues = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yValues = [parseFloat(b) / coeffs[vars[1]], 0];

                    let constraintTrace = {
                        x: xValues,
                        y: yValues,
                        mode: 'lines',
                        type: 'scatter',
                        name: `Contrainte ${index + 1}`,
                        line: { color: colors[index % colors.length], width: 2 }
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    xaxis: { title: vars[0] },
                    yaxis: { title: vars[1] },
                    showlegend: true
                };

                Plotly.newPlot(graphContainer, traces, layout);

            } else if (vars.length === 3) {
                // 3D Plot
                let solutionTrace = {
                    x: [values[0]],
                    y: [values[1]],
                    z: [values[2]],
                    mode: 'markers+text',
                    type: 'scatter3d',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split('<=').map(x => x.trim());
                    let coeffs = parseExpr(lhs);
                    let xRange = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yRange = [0, parseFloat(b) / coeffs[vars[1]]];
                    let zRange = [0, parseFloat(b) / coeffs[vars[2]]];

                    let zValues = xRange.map(x => (parseFloat(b) - coeffs[vars[0]] * x) / coeffs[vars[2]]);
                    let yValues = yRange.map(y => (parseFloat(b) - coeffs[vars[1]] * y) / coeffs[vars[2]]);

                    let constraintTrace = {
                        x: xRange,
                        y: yRange,
                        z: zValues,
                        mode: 'lines',
                        type: 'scatter3d',
                        name: `Contrainte ${index + 1}`,
                        surfaceaxis: 2,
                        line: { color: colors[index % colors.length], width: 2 }
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    scene: {
                        xaxis: { title: vars[0] },
                        yaxis: { title: vars[1] },
                        zaxis: { title: vars[2] }
                    }
                };

                Plotly.newPlot(graphContainer, traces, layout);
            }
        }
    </script>
</body>

</html>
