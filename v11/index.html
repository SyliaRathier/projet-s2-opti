<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OptiSolve - Résolution de Problèmes d'Optimisation</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.1.1/src/bold/style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <style>
        /* Variables CSS pour les thèmes clair et sombre */
        :root {
            --background-color: #f8f9fa;
            --text-color: #2d3748;
            --input-background: #fff;
            --input-border: #e2e8f0;
            --button-background: linear-gradient(to right, #6366f1, #3b82f6);
            --button-hover: linear-gradient(to right, #4f46e5, #2563eb);
            --button-active: linear-gradient(to right, #4338ca, #1d4ed8);
            --result-background: #e6f0ff;
            /* Light blue for sections */
            --result-border: #b3d9ff;
            --table-header: #f0f4f8;
            --table-even: rgba(241, 245, 249, 0.5);
            --pivot-row: #e3f0fd;
            /* bleu très clair */
            --pivot-col: #bee3f8;
            /* bleu clair */
            --pivot-cell: #3182ce;
            /* bleu vif */
            --pivot-cell-font: #fff;
            /* texte blanc pour bonne visibilité */
        }

        .dark-mode {
            --background-color: #1a202c;
            --text-color: #f7fafc;
            --input-background: #2d3748;
            --input-border: #4a5568;
            --button-background: linear-gradient(to right, #667eea, #5a67d8);
            --button-hover: linear-gradient(to right, #5a67d8, #4c51bf);
            --button-active: linear-gradient(to right, #4c51bf, #3182ce);
            --result-background: #283149;
            /* Darker blue for sections in dark mode */
            --result-border: #3e4c66;
            --table-header: #2d3748;
            --table-even: #1a202c;
            --pivot-row: #2c5282;
            --pivot-col: #2b6cb0;
            --pivot-cell: #3182ce;
            --pivot-row-font: #f7fafc;
        }

        /* Styles généraux pour le corps et le conteneur principal */
        body {
            font-family: 'Inter', sans-serif;
            background: var(--background-color);
            color: var(--text-color);
            transition: background 0.3s, color 0.3s;
        }

        .container {
            background-color: var(--input-background);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
                0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            width: 100%;
            max-width: 60rem;
            color: var(--text-color);
            transition: background 0.3s, color 0.3s;
        }

        /* Styles pour les champs de saisie et les sélecteurs */
        input,
        select {
            background-color: var(--input-background);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            width: 100%;
            transition: all 0.2s ease-in-out;
        }

        input:focus,
        select:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            outline: none;
        }

        input::placeholder,
        textarea::placeholder {
            color: #a0aec0;
        }

        .dark-mode input::placeholder,
        .dark-mode textarea::placeholder {
            color: #d1d5db;
        }

        /* Styles pour les boutons généraux */
        button {
            background: var(--button-background);
            color: white;
            border: none;
            border-radius: 9999px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(99, 102, 241, 0.5);
            transition: background 0.3s, box-shadow 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: var(--button-hover);
            box-shadow: 0 6px 12px rgba(79, 70, 229, 0.7);
        }

        button:active {
            background: var(--button-active);
            box-shadow: none;
        }

        button i {
            margin-right: 0.5rem;
        }

        /* Styles pour les sections de sortie/résultats */
        #output-section,
        #tableaux-section,
        #graph-section,
        #sensitivity-section,
        #saved-problems-section {
            background-color: var(--result-background);
            border: 1px solid var(--result-border);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            overflow: hidden;
            color: var(--text-color);
        }

        /* Styles pour les tableaux */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            color: inherit;
            /* Inherit text color from parent */
        }

        table th,
        table td {
            border: 1px solid var(--input-border);
            padding: 0.75rem;
            text-align: center;
        }

        table th {
            background-color: var(--table-header);
            font-weight: 600;
        }

        table tr:nth-child(even) {
            background-color: var(--table-even);
        }

        /* Classes pour la mise en évidence des éléments pivots dans les tableaux */
        .pivot-row {
            background-color: var(--pivot-row) !important;
            font-weight: bold;
        }

        .pivot-col {
            background-color: var(--pivot-col) !important;
            font-weight: bold;
        }

        .pivot-cell {
            background-color: var(--pivot-cell) !important;
            color: var(--pivot-cell-font) !important;
            font-weight: bold;
        }

        /* Bouton de bascule du mode clair/sombre */
        .mode-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #6366f1;
            /* Fixed background, could use var(--button-background) here too */
            color: white;
            border: none;
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgb(99 102 241 / 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, transform 0.3s ease;
            z-index: 10;
            /* Ensure it's above other content */
        }

        .mode-toggle:hover {
            background-color: #4f46e5;
            transform: translateY(-2px) scale(1.1);
        }

        .mode-toggle:active {
            background-color: #4338ca;
            transform: translateY(0) scale(0.9);
            box-shadow: 0 1px 3px rgb(67 56 202 / 0.6);
        }

        .mode-toggle i {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            width: 100%;
            height: 100%;
            margin: 0 !important;
            /* retire les marges héritées */
        }

        .dark-mode .mode-toggle i {
            transform: rotate(30deg);
        }

        /* Overrides pour les boutons spécifiques (résoudre, sauvegarder) */
        #solve-button,
        #save-button {
            background: var(--button-background);
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgb(79 70 229 / 0.7);
            border: none;
            cursor: pointer;
            transition: background 0.3s, box-shadow 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #solve-button:hover,
        #save-button:hover {
            background: var(--button-hover);
            box-shadow: 0 6px 12px rgb(67 56 202 / 0.8);
        }

        #solve-button:active,
        #save-button:active {
            background: var(--button-active);
            box-shadow: none;
        }

        #solve-button i,
        #save-button i {
            margin-right: 0.5rem;
        }

        /* Surcharge des couleurs de texte pour le mode sombre */
        .dark-mode label,
        .dark-mode .text-gray-600,
        .dark-mode .text-gray-700,
        .dark-mode .text-gray-800,
        .dark-mode .text-indigo-800 {
            color: var(--text-color) !important;
        }

        .dark-mode .bg-indigo-50 {
            background-color: var(--result-background) !important;
            color: var(--text-color) !important;
        }

        .dark-mode .bg-indigo-50 * {
            color: var(--text-color) !important;
        }
    </style>
</head>

<body class="min-h-screen flex flex-col items-center py-10 px-4 transition-colors duration-300">

    <div id="custom-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="modal-message" class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4"></p>
            <div id="modal-buttons" class="flex justify-center space-x-4">
                <button id="modal-ok-button"
                    class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-full hover:bg-indigo-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    OK
                </button>
                <button id="modal-cancel-button"
                    class="bg-gray-400 text-white font-bold py-2 px-6 rounded-full hover:bg-gray-500 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-300 hidden">
                    Annuler
                </button>
            </div>
        </div>
    </div>

    <button class="mode-toggle" onclick="toggleMode()" aria-label="Toggle dark mode">
        <i class="ph-bold ph-moon"></i>
    </button>

    <div class="container flex flex-col md:flex-row md:space-x-8 max-w-7xl">
        <div class="md:w-2/3">
            <h1 class="text-3xl font-bold text-center text-blue-800 dark:text-indigo-400 mb-4">Méthode du simplexe</h1>
            <p class="text-gray-700 dark:text-gray-400 text-center mb-6">
                Résolvez vos problèmes d'optimisation linéaire avec la méthode du Simplex.
            </p>

            <div id="input-section"
                class="mb-8 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    1. Entrez les données du problème
                </div>
                <div class="p-5 space-y-4 bg-white dark:bg-gray-800">
                    <div>
                        <label for="optimization-type"
                            class="block text-gray-700 dark:text-gray-300 text-sm font-semibold mb-1">Type
                            d'optimisation:</label>
                        <select id="optimization-type"
                            class="border border-gray-300 dark:border-gray-600 rounded-lg w-full py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700 focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-500">
                            <option value="max">Maximisation</option>
                            <option value="min">Minimisation</option>
                        </select>
                    </div>

                    <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4">
                        <div class="flex-1">
                            <label for="objective-name"
                                class="block text-gray-700 dark:text-gray-300 text-sm font-semibold mb-1">Nom de la
                                Fonction Objective:</label>
                            <input type="text" id="objective-name" placeholder="Nom de la fonction"
                                class="border border-gray-300 dark:border-gray-600 rounded-lg w-full py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700 focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-500" />
                        </div>

                        <div class="flex-1">
                            <label for="objective-function"
                                class="block text-gray-700 dark:text-gray-300 text-sm font-semibold mb-1">Fonction
                                Objective (e.g., 3x + 5y):</label>
                            <input type="text" id="objective-function" placeholder="3x + 5y"
                                class="border border-gray-300 dark:border-gray-600 rounded-lg w-full py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700 focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-500" />
                        </div>
                    </div>

                    <div>
                        <label
                            class="block text-gray-700 dark:text-gray-300 text-sm font-semibold mb-2">Contraintes:</label>
                        <div id="constraints-container">
                            <div
                                class="constraint-group flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-3 mb-3">
                                <input type="text" placeholder="Nom de la contrainte"
                                    class="constraint-name flex-1 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />

                                <input type="text" placeholder="2x + y"
                                    class="constraint-expression flex-1 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />

                                <select
                                    class="constraint-operator border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700 w-full sm:w-auto">
                                    <option value="<=">≤</option>
                                    <option value=">=">≥</option>
                                    <option value="=">=</option>
                                </select>

                                <input type="text" placeholder="10"
                                    class="constraint-value w-full sm:w-20 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />

                                <button type="button"
                                    class="add-constraint bg-indigo-600 hover:bg-indigo-700 text-white rounded-full p-2 transition flex items-center justify-center min-w-[36px] min-h-[36px]">
                                    <i class="ph-bold ph-plus"></i>
                                </button>
                            </div>

                        </div>
                    </div>

                    <div class="text-center pt-4">
                        <button id="solve-button">
                            <i class="ph-bold ph-rocket"></i> Résoudre le problème
                        </button>
                    </div>
                </div>
            </div>

            <div id="output-section"
                class="hidden mb-8 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    2. Solution</div>
                <div class="p-5 bg-white dark:bg-gray-800">
                    <div id="solution-text" class="text-lg font-medium text-gray-800 dark:text-gray-200"></div>
                    <div class="text-center pt-4">
                        <button id="save-button"
                            class="bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-semibold py-2 px-4 rounded-full shadow-md hover:shadow-lg transition-all duration-300">
                            <i class="ph-bold ph-floppy-disk"></i> Sauvegarder le problème
                        </button>
                    </div>
                </div>
            </div>

            <div id="tableaux-section"
                class="hidden mb-8 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    3. Tableaux du Simplexe</div>
                <div class="p-5 bg-white dark:bg-gray-800 overflow-x-auto">
                    <div id="tableauxResults"></div>
                </div>
            </div>

            <div id="graph-section"
                class="hidden mb-8 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    4. Représentation Graphique</div>
                <div class="p-5 bg-white dark:bg-gray-800">
                    <div id="plot"></div>
                </div>
            </div>

            <div id="sensitivity-section"
                class="hidden border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    5. Analyse de Sensibilité</div>
                <div class="p-5 bg-white dark:bg-gray-800">
                    <div id="sensitivity-text" class="text-md text-gray-700 dark:text-gray-300"></div>
                </div>
            </div>
        </div>

        <div class="md:w-1/3 mt-8 md:mt-0">
            <div id="saved-problems-section"
                class="mb-8 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-lg">
                <div
                    class="bg-indigo-50 dark:bg-gray-700 py-3 px-5 font-semibold text-indigo-800 dark:text-gray-200 text-lg">
                    6. Problèmes Sauvegardés</div>
                <div class="p-5 bg-white dark:bg-gray-800">
                    <div id="saved-problems-list" class="space-y-2">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="./simplexe2phases.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // --- Custom Modal Logic ---
        const customModal = document.getElementById('custom-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        let currentModalCallback = null;

        /**
         * Affiche un modal personnalisé avec un message et des boutons.
         * @param {string} message - Le message à afficher dans le modal.
         * @param {'ok'|'confirm'} type - Le type de modal ('ok' pour un seul bouton OK, 'confirm' pour OK et Annuler).
         * @param {function(boolean): void} [callback] - Fonction de rappel appelée lorsque l'utilisateur clique sur OK (true) ou Annuler (false).
         */
        function showModal(message, type = 'ok', callback = null) {
            modalMessage.textContent = message;
            customModal.classList.remove('hidden');
            currentModalCallback = callback;

            if (type === 'confirm') {
                modalOkButton.textContent = 'Confirmer';
                modalCancelButton.classList.remove('hidden');
            } else {
                modalOkButton.textContent = 'OK';
                modalCancelButton.classList.add('hidden');
            }
        }

        /** Cache le modal personnalisé. */
        function hideModal() {
            customModal.classList.add('hidden');
            currentModalCallback = null;
        }

        modalOkButton.addEventListener('click', () => {
            if (currentModalCallback) {
                currentModalCallback(true); // Passe true pour OK/Confirmer
            }
            hideModal();
        });

        modalCancelButton.addEventListener('click', () => {
            if (currentModalCallback) {
                currentModalCallback(false); // Passe false pour Annuler
            }
            hideModal();
        });

        // --- Fonction de bascule du mode clair/sombre ---
        function toggleMode() {
            const body = document.body;
            const modeToggle = document.querySelector('.mode-toggle');
            const icon = modeToggle.querySelector('i');

            body.classList.toggle('dark-mode');

            // Sauvegarde la préférence dans le localStorage
            if (body.classList.contains('dark-mode')) {
                localStorage.setItem('theme', 'dark');
                icon.classList.replace('ph-moon', 'ph-sun'); // Change l'icône en soleil
                modeToggle.setAttribute('aria-label', 'Passer en mode clair');
            } else {
                localStorage.setItem('theme', 'light');
                icon.classList.replace('ph-sun', 'ph-moon'); // Change l'icône en lune
                modeToggle.setAttribute('aria-label', 'Passer en mode sombre');
            }
        }

        // --- Variables et écouteurs d'événements pour la logique de l'application ---
        const objectiveFunctionInput = document.getElementById('objective-function');
        const constraintsContainer = document.getElementById('constraints-container');
        const solveButton = document.getElementById('solve-button');
        const outputSection = document.getElementById('output-section');
        const solutionText = document.getElementById('solution-text');
        const graphSection = document.getElementById('graph-section');
        // graphCanvas est commenté car il n'est pas utilisé directement dans plotSolution avec Plotly
        // const graphCanvas = document.getElementById('graph-canvas');
        const sensitivitySection = document.getElementById('sensitivity-section');
        const sensitivityText = document.getElementById('sensitivity-text');
        const tableauxSection = document.getElementById('tableaux-section');
        const saveButton = document.getElementById('save-button'); // Référence au bouton de sauvegarde

        let chartInstance = null; // Pour Chart.js si utilisé, mais Plotly est utilisé ici
        let currentResult = null; // Stocke le dernier résultat de résolution

        /**
         * Met à jour les boutons d'ajout/suppression de contraintes.
         * Assure que seul le dernier groupe de contraintes a un bouton d'ajout.
         */
        function updateConstraintButtons() {
            const constraintGroups = constraintsContainer.querySelectorAll('.constraint-group');
            constraintGroups.forEach((group, index) => {
                let removeButton = group.querySelector('.remove-constraint');
                if (removeButton) {
                    removeButton.remove(); // Supprime le bouton existant pour le recréer si nécessaire
                }

                // Ajoute un bouton de suppression si plus d'une contrainte
                if (constraintGroups.length > 1) {
                    removeButton = document.createElement('button');
                    removeButton.setAttribute('type', 'button');
                    removeButton.classList.add(
                        'remove-constraint',
                        'bg-red-500', 'hover:bg-red-600', 'text-white', 'rounded-full', 'p-2', 'transition',
                        'flex', 'items-center', 'justify-center', 'min-w-[36px]', 'min-h-[36px]'
                    );
                    removeButton.setAttribute('title', 'Supprimer la contrainte');
                    removeButton.innerHTML = '<i class="ph-bold ph-minus"></i>';
                    removeButton.onclick = () => {
                        group.remove();
                        updateConstraintButtons(); // Met à jour les boutons après la suppression
                    };
                    group.appendChild(removeButton);
                }

                // S'assure que seul le dernier groupe de contraintes a le bouton d'ajout
                const currentAddButton = group.querySelector('.add-constraint');
                if (index === constraintGroups.length - 1) {
                    if (!currentAddButton) {
                        const newAddButton = document.createElement('button');
                        newAddButton.setAttribute('type', 'button');
                        newAddButton.classList.add(
                            'add-constraint',
                            'bg-indigo-600', 'hover:bg-indigo-700', 'text-white', 'rounded-full', 'p-2', 'transition',
                            'flex', 'items-center', 'justify-content-center', 'min-w-[36px]', 'min-h-[36px]'
                        );
                        newAddButton.setAttribute('title', 'Ajouter une contrainte');
                        newAddButton.innerHTML = '<i class="ph-bold ph-plus"></i>';
                        newAddButton.onclick = handleAddConstraint;
                        group.appendChild(newAddButton);
                    }
                } else {
                    if (currentAddButton) {
                        currentAddButton.remove();
                    }
                }
            });
        }

        /** Ajoute un nouveau groupe de champs pour une contrainte. */
        function handleAddConstraint() {
            const newConstraintGroup = document.createElement('div');
            newConstraintGroup.classList.add('constraint-group', 'flex', 'flex-col', 'sm:flex-row', 'items-center', 'space-y-3', 'sm:space-y-0', 'sm:space-x-3', 'mb-3');
            newConstraintGroup.innerHTML = `
                <input type="text" placeholder="Nom de la contrainte"
                    class="constraint-name flex-1 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />

                <input type="text" placeholder="2x + y"
                    class="constraint-expression flex-1 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />

                <select
                    class="constraint-operator border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700 w-full sm:w-auto">
                    <option value="<=">≤</option>
                    <option value=">=">≥</option>
                    <option value="=">=</option>
                </select>

                <input type="text" placeholder="10"
                    class="constraint-value w-full sm:w-20 border border-gray-300 dark:border-gray-600 rounded-lg py-2 px-3 text-gray-800 dark:text-gray-100 bg-gray-50 dark:bg-gray-700" />
            `;
            constraintsContainer.appendChild(newConstraintGroup);
            updateConstraintButtons(); // Met à jour les boutons après l'ajout
        }

        // Écouteur pour le bouton de résolution
        solveButton.addEventListener('click', () => {
            try {
                const objectiveFunction = objectiveFunctionInput.value;
                const optimizationType = document.getElementById('optimization-type').value;
                const constraints = [];
                const constraintGroups = constraintsContainer.querySelectorAll('.constraint-group');
                constraintGroups.forEach(group => {
                    const nameInput = group.querySelector('.constraint-name');
                    const expressionInput = group.querySelector('.constraint-expression');
                    const operatorSelect = group.querySelector('.constraint-operator');
                    const valueInput = group.querySelector('.constraint-value');
                    constraints.push({
                        name: nameInput.value,
                        expression: expressionInput.value,
                        operator: operatorSelect.value,
                        value: parseFloat(valueInput.value)
                    });
                });

                if (!objectiveFunction) {
                    throw new Error("Veuillez entrer une fonction objective.");
                }
                if (constraints.length === 0) {
                    throw new Error("Veuillez entrer au moins une contrainte.");
                }

                // Vérifie si LinearProgrammingSolver est défini (vient de simplexe2phases.js)
                if (typeof LinearProgrammingSolver === 'undefined') {
                    throw new Error("Le solveur de programmation linéaire (simplexe2phases.js) n'est pas chargé.");
                }

                const problem = parseProblem(objectiveFunction, constraints, optimizationType);

                console.log("Problème analysé:", problem);
                const solver = new LinearProgrammingSolver(problem);
                const result = solver.solve();
                console.log("Résultat du solveur:", result);

                // Stocker le résultat dans la variable globale
                currentResult = result;

                displaySolution(result, problem);
                displayTableaux(result.tableaux);
                plotSolution(problem, result);
                displaySensitivityAnalysis(result, constraints);

                outputSection.classList.remove('hidden');
                tableauxSection.classList.remove('hidden');
                graphSection.classList.remove('hidden');
                sensitivitySection.classList.remove('hidden');

            } catch (error) {
                showModal("Erreur : " + error.message, 'ok');
            }
        });

        /**
         * Analyse les données du formulaire pour créer un objet problème compatible avec le solveur.
         * @param {string} objectiveFunction - L'expression de la fonction objective (ex: "3x + 5y").
         * @param {Array<Object>} constraints - Tableau d'objets contraintes.
         * @param {string} optimizationType - Type d'optimisation ('max' ou 'min').
         * @returns {Object} L'objet problème analysé.
         */
        function parseProblem(objectiveFunction, constraints, optimizationType) {
            const objectiveName = document.getElementById('objective-name').value || 'objectif';
            const problem = {
                optimize: objectiveName,
                opType: optimizationType,
                constraints: {},
                variables: {}
            };

            // Analyser la fonction objective
            const objectiveParts = objectiveFunction.split(/([+-]?\d*\.?\d*[a-zA-Z]+)/).filter(Boolean);
            objectiveParts.forEach(part => {
                const match = part.match(/([+-]?\d*\.?\d*)([a-zA-Z]+)/);
                if (match) {
                    const coeff = match[1] === '-' ? -1 : match[1] === '+' ? 1 : parseFloat(match[1] || 1);
                    const varName = match[2];
                    problem.variables[varName] = { [objectiveName]: coeff };
                }
            });

            // Analyser les contraintes
            constraints.forEach((constraint, index) => {
                const constraintName = constraint.name || `c${index + 1}`;
                const parts = constraint.expression.split(/([+-]?\d*\.?\d*[a-zA-Z]+)/).filter(Boolean);
                const constraintObj = {};

                parts.forEach(part => {
                    const match = part.match(/([+-]?\d*\.?\d*)([a-zA-Z]+)/);
                    if (match) {
                        const coeff = match[1] === '-' ? -1 : match[1] === '+' ? 1 : parseFloat(match[1] || 1);
                        const varName = match[2];
                        if (problem.variables[varName]) {
                            problem.variables[varName][constraintName] = coeff;
                        } else {
                            problem.variables[varName] = { [constraintName]: coeff };
                        }
                    }
                });

                if (constraint.operator === '<=') {
                    constraintObj.max = parseFloat(constraint.value);
                } else if (constraint.operator === '>=') {
                    constraintObj.min = parseFloat(constraint.value);
                } else if (constraint.operator === '=') {
                    constraintObj.equal = parseFloat(constraint.value);
                }

                problem.constraints[constraintName] = constraintObj;
            });

            return problem;
        }

        /**
         * Affiche la solution optimale.
         * @param {Object} result - L'objet résultat du solveur.
         * @param {Object} problem - L'objet problème analysé.
         */
        function displaySolution(result, problem) {
            let solutionTextString = "<div class='solution-container text-gray-800 dark:text-gray-200'>";
            solutionTextString += "<h3 class='text-xl font-semibold text-indigo-700 dark:text-indigo-400 mb-2'>Solution Optimale</h3>";
            solutionTextString += `<p class='mb-2'>La solution optimale de la fonction objective ${problem.optimize} est atteinte pour :</p>`;
            solutionTextString += "<ul class='list-disc list-inside mb-4'>";
            for (const [variable, value] of Object.entries(result.variables)) {
                solutionTextString += `<li>${variable} = ${value.toFixed(3)}</li>`; // Arrondi pour l'affichage
            }
            solutionTextString += "</ul>";
            solutionTextString += `<p class='font-bold'>Valeur de la fonction objective ${problem.optimize} : ${result.p.toFixed(2)}</p>`;
            solutionTextString += "</div>";
            solutionText.innerHTML = solutionTextString;
        }

        /**
         * Affiche les tableaux du simplexe.
         * @param {Array<Object>} tableaux - Tableau des tableaux du simplexe.
         */
        function displayTableaux(tableaux) {
            const tableauxResultsDiv = document.getElementById('tableauxResults');
            tableauxResultsDiv.innerHTML = '';

            tableaux.forEach((tab, i) => {
                const tableauContainer = document.createElement('div');
                tableauContainer.classList.add('tableau-container', 'mb-6', 'overflow-x-auto'); // Ajout de overflow-x-auto
                tableauContainer.innerHTML = `<h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-400 mb-2">Tableau ${i + 1}:</h3>`;

                const table = document.createElement('table');
                table.classList.add('min-w-full', 'divide-y', 'divide-gray-200', 'dark:divide-gray-700', 'shadow-md', 'rounded-lg', 'overflow-hidden');
                const thead = document.createElement('thead');
                thead.classList.add('bg-gray-50', 'dark:bg-gray-700');
                const tbody = document.createElement('tbody');
                tbody.classList.add('bg-white', 'dark:bg-gray-800', 'divide-y', 'divide-gray-200', 'dark:divide-gray-700');


                // Headers
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Basis</th>` + tab.headers.map(header => `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">${header}</th>`).join('');
                thead.appendChild(headerRow);

                // Trouver colonne pivot (plus négatif dans ligne obj)
                const objRow = tab.rows[tab.rows.length - 1];
                const pivotCol = objRow.slice(0, -1).reduce((minIdx, val, idx, arr) => val < arr[minIdx] ? idx : minIdx, 0);
                const isUnbounded = objRow[pivotCol] >= 0;
                let pivotRow = -1;

                if (!isUnbounded) {
                    const ratios = tab.rows.slice(0, -1).map((row, i) => {
                        const rhs = row[row.length - 1];
                        const val = row[pivotCol];
                        return val > 0 ? rhs / val : Infinity;
                    });
                    const minRatio = Math.min(...ratios);
                    pivotRow = ratios.indexOf(minRatio);
                }

                // Rows
                tab.rows.forEach((row, rIdx) => {
                    const tr = document.createElement('tr');
                    tr.classList.add('hover:bg-gray-100', 'dark:hover:bg-gray-700');
                    const label = rIdx < tab.basis.length ? "*" + tab.basis[rIdx] : "Z";

                    tr.innerHTML = `<td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">${label}</td>` + row.map((val, cIdx) => {
                        let cellClass = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100';
                        if (rIdx === pivotRow && cIdx === pivotCol) cellClass += ' pivot-cell';
                        else if (rIdx === pivotRow) cellClass += ' pivot-row';
                        else if (cIdx === pivotCol) cellClass += ' pivot-col';

                        return `<td class="${cellClass}">${(Math.round(val * 1000) / 1000).toFixed(3)}</td>`;
                    }).join('');

                    tbody.appendChild(tr);
                });

                table.appendChild(thead);
                table.appendChild(tbody);
                tableauContainer.appendChild(table);
                tableauxResultsDiv.appendChild(tableauContainer);
            });
        }

        /**
         * Trace la solution graphique (2D ou 3D).
         * @param {Object} problem - L'objet problème analysé.
         * @param {Object} result - L'objet résultat du solveur.
         */
        function plotSolution(problem, result) {
            const plotDiv = document.getElementById('plot');
            const variables = Object.keys(problem.variables);

            if (variables.length === 2) {
                plot2D(problem, result, plotDiv);
            } else if (variables.length === 3) {
                plot3D(problem, result, plotDiv);
            } else {
                plotDiv.innerHTML = '<p class="text-gray-700 dark:text-gray-300">La visualisation graphique est disponible pour les problèmes à 2 ou 3 variables.</p>';
                Plotly.newPlot(plotDiv, [], {}); // Efface tout tracé précédent
            }
        }

        /**
         * Trace la solution en 2D.
         * @param {Object} problem - L'objet problème analysé.
         * @param {Object} result - L'objet résultat du solveur.
         * @param {HTMLElement} plotDiv - L'élément DIV où tracer le graphique.
         */
        function plot2D(problem, result, plotDiv) {
            const data = [];

            const xVar = Object.keys(problem.variables)[0];
            const yVar = Object.keys(problem.variables)[1];

            const constraints = problem.constraints;
            const variables = problem.variables;

            let maxX = 0;
            let maxY = 0;
            for (const conKey in constraints) {
                const conType = Object.keys(constraints[conKey])[0];
                const rhs = constraints[conKey][conType];
                const xCoeff = variables[xVar]?.[conKey] || 0;
                const yCoeff = variables[yVar]?.[conKey] || 0;

                if (xCoeff !== 0) maxX = Math.max(maxX, rhs / xCoeff);
                if (yCoeff !== 0) maxY = Math.max(maxY, rhs / yCoeff);
            }

            maxX = Math.max(maxX, (result.variables[xVar] || 0) * 1.5 + 5, 10); // Assure une taille minimale
            maxY = Math.max(maxY, (result.variables[yVar] || 0) * 1.5 + 5, 10); // Assure une taille minimale


            const layout = {
                title: 'Région Faisable et Fonction Objective (2D)',
                xaxis: {
                    title: xVar,
                    range: [0, maxX],
                    zeroline: true,
                    zerolinecolor: '#969696',
                    gridcolor: '#e0e0e0'
                },
                yaxis: {
                    title: yVar,
                    range: [0, maxY],
                    zeroline: true,
                    zerolinecolor: '#969696',
                    gridcolor: '#e0e0e0'
                },
                hovermode: 'closest',
                showlegend: true,
                paper_bgcolor: 'var(--input-background)', // Utilise la variable CSS
                plot_bgcolor: 'var(--input-background)', // Utilise la variable CSS
                font: {
                    color: 'var(--text-color)' // Utilise la variable CSS
                }
            };

            // Contraintes de non-négativité
            data.push({
                x: [0, maxX], y: [0, 0], mode: 'lines', name: `${xVar} ≥ 0`, line: { dash: 'dot', color: 'gray' }
            });
            data.push({
                x: [0, 0], y: [0, maxY], mode: 'lines', name: `${yVar} ≥ 0`, line: { dash: 'dot', color: 'gray' }
            });

            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            let colorIndex = 0;

            // Tracer les contraintes
            for (const conKey in constraints) {
                const conType = Object.keys(constraints[conKey])[0];
                const rhs = constraints[conKey][conType];
                const xCoeff = variables[xVar]?.[conKey] || 0;
                const yCoeff = variables[yVar]?.[conKey] || 0;

                if (xCoeff === 0 && yCoeff === 0) continue;

                let x_vals = [];
                let y_vals = [];

                if (yCoeff !== 0) {
                    x_vals = Array.from({ length: 100 }, (_, i) => i * (maxX / 99));
                    y_vals = x_vals.map(x => (rhs - xCoeff * x) / yCoeff);
                } else if (xCoeff !== 0) {
                    const xVal = rhs / xCoeff;
                    x_vals = [xVal, xVal];
                    y_vals = [0, maxY];
                }

                data.push({
                    x: x_vals,
                    y: y_vals,
                    mode: 'lines',
                    name: `${conKey} (${conType} ${rhs})`,
                    line: { width: 2, color: colors[colorIndex % colors.length] }
                });

                colorIndex++;
            }

            // Point optimal
            const optimalX = result.variables[xVar] || 0;
            const optimalY = result.variables[yVar] || 0;
            data.push({
                x: [optimalX],
                y: [optimalY],
                mode: 'markers',
                type: 'scatter',
                name: `Solution Optimale (p = ${result.p.toFixed(2)})`,
                marker: { size: 12, color: 'red', symbol: 'star' }
            });

            Plotly.newPlot(plotDiv, data, layout);
        }

        /**
         * Trace la solution en 3D.
         * @param {Object} problem - L'objet problème analysé.
         * @param {Object} result - L'objet résultat du solveur.
         * @param {HTMLElement} plotDiv - L'élément DIV où tracer le graphique.
         */
        function plot3D(problem, result, plotDiv) {
            const data = [];
            const layout = {
                title: 'Région Faisable et Fonction Objective (3D)',
                showlegend: true,
                scene: {
                    xaxis: { title: Object.keys(problem.variables)[0], zerolinecolor: '#969696', gridcolor: '#e0e0e0' },
                    yaxis: { title: Object.keys(problem.variables)[1], zerolinecolor: '#969696', gridcolor: '#e0e0e0' },
                    zaxis: { title: Object.keys(problem.variables)[2], zerolinecolor: '#969696', gridcolor: '#e0e0e0' }
                },
                legend: {
                    x: 1,
                    y: 1
                },
                paper_bgcolor: 'var(--input-background)',
                plot_bgcolor: 'var(--input-background)',
                font: {
                    color: 'var(--text-color)'
                }
            };

            const xVar = Object.keys(problem.variables)[0];
            const yVar = Object.keys(problem.variables)[1];
            const zVar = Object.keys(problem.variables)[2];

            const constraints = problem.constraints;
            const variables = problem.variables;

            let maxX = 0,
                maxY = 0,
                maxZ = 0;
            for (const conKey in constraints) {
                const conType = Object.keys(constraints[conKey])[0];
                const rhs = constraints[conKey][conType];
                const xCoeff = variables[xVar]?.[conKey] || 0;
                const yCoeff = variables[yVar]?.[conKey] || 0;
                const zCoeff = variables[zVar]?.[conKey] || 0;

                if (xCoeff !== 0) maxX = Math.max(maxX, rhs / xCoeff);
                if (yCoeff !== 0) maxY = Math.max(maxY, rhs / yCoeff);
                if (zCoeff !== 0) maxZ = Math.max(maxZ, rhs / zCoeff);
            }
            maxX = Math.max(maxX, (result.variables[xVar] || 0) * 1.5 + 5, 10);
            maxY = Math.max(maxY, (result.variables[yVar] || 0) * 1.5 + 5, 10);
            maxZ = Math.max(maxZ, (result.variables[zVar] || 0) * 1.5 + 5, 10);


            const numPoints = 20;
            const x_range = Array.from({ length: numPoints }, (_, i) => i * (maxX / (numPoints - 1)));
            const y_range = Array.from({ length: numPoints }, (_, i) => i * (maxY / (numPoints - 1)));

            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            let colorIndex = 0;

            for (const conKey in constraints) {
                const conType = Object.keys(constraints[conKey])[0];
                const rhs = constraints[conKey][conType];
                const xCoeff = variables[xVar]?.[conKey] || 0;
                const yCoeff = variables[yVar]?.[conKey] || 0;
                const zCoeff = variables[zVar]?.[conKey] || 0;

                if (xCoeff === 0 && yCoeff === 0 && zCoeff === 0) continue;

                const z_vals = [];
                for (let i = 0; i < numPoints; i++) {
                    const row = [];
                    for (let j = 0; j < numPoints; j++) {
                        let z_val;
                        if (zCoeff !== 0) {
                            z_val = (rhs - xCoeff * x_range[i] - yCoeff * y_range[j]) / zCoeff;
                        } else if (yCoeff !== 0) {
                            z_val = (rhs - xCoeff * x_range[i]) / yCoeff;
                        } else if (xCoeff !== 0) {
                            z_val = rhs / xCoeff;
                        } else {
                            z_val = 0;
                        }
                        row.push(z_val);
                    }
                    z_vals.push(row);
                }

                const color = colors[colorIndex % colors.length];
                const constraintName = `${conKey} (${conType} ${rhs})`;

                // Trace surface
                data.push({
                    x: x_range,
                    y: y_range,
                    z: z_vals,
                    type: 'surface',
                    showscale: false,
                    name: constraintName,
                    opacity: 0.5,
                    hoverinfo: 'name',
                    colorscale: [[0, color], [1, color]],
                    legendgroup: constraintName,
                    showlegend: false
                });

                // Fake trace for legend
                data.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: [null],
                    y: [null],
                    z: [null],
                    name: constraintName,
                    legendgroup: constraintName,
                    line: { color: color },
                    showlegend: true
                });

                colorIndex++;
            }

            // Optimal solution point
            const optimalX = result.variables[xVar] || 0;
            const optimalY = result.variables[yVar] || 0;
            const optimalZ = result.variables[zVar] || 0;

            data.push({
                x: [optimalX],
                y: [optimalY],
                z: [optimalZ],
                mode: 'markers',
                type: 'scatter3d',
                name: `Solution Optimale (p=${result.p.toFixed(2)})`,
                marker: { size: 8, color: 'red', symbol: 'circle' },
                showlegend: true
            });

            Plotly.newPlot(plotDiv, data, layout);
        }

        /**
         * Affiche l'analyse de sensibilité.
         * @param {Object} result - L'objet résultat du solveur.
         * @param {Array<Object>} constraints - Tableau d'objets contraintes.
         */
        function displaySensitivityAnalysis(result, constraints) {
            let sensitivityTextString = "<h3 class='text-xl font-semibold text-indigo-700 dark:text-indigo-400 mb-2'>Analyse de Sensibilité</h3>";
            if (result.sensitivity && result.sensitivity.length > 0) {
                sensitivityTextString += "<ul class='list-disc list-inside mb-4'>";
                result.sensitivity.forEach(s => {
                    sensitivityTextString += `<li>- Contrainte ${s.constraint}: Prix dual = ${s.shadowPrice.toFixed(2)}, Augmentation permise = ${s.allowableIncrease.toFixed(2)}, Diminution permise = ${s.allowableDecrease.toFixed(2)}</li>`;
                });
                sensitivityTextString += "</ul>";
                sensitivityText.innerHTML = sensitivityTextString;
            } else {
                sensitivityText.innerHTML = "<p class='text-gray-700 dark:text-gray-300'>L'analyse de sensibilité n'est pas disponible pour ce problème.</p>";
            }
        }

        // --- Fonctions pour la sauvegarde et le chargement des problèmes ---

        // Fonction pour sauvegarder le problème actuel dans le local storage
        saveButton.addEventListener('click', () => {
            const objectiveFunction = objectiveFunctionInput.value;
            const optimizationType = document.getElementById('optimization-type').value;
            const objectiveName = document.getElementById('objective-name').value;
            const constraints = [];

            const constraintGroups = constraintsContainer.querySelectorAll('.constraint-group');
            constraintGroups.forEach(group => {
                const nameInput = group.querySelector('.constraint-name');
                const expressionInput = group.querySelector('.constraint-expression');
                const operatorSelect = group.querySelector('.constraint-operator');
                const valueInput = group.querySelector('.constraint-value');
                constraints.push({
                    name: nameInput.value,
                    expression: expressionInput.value,
                    operator: operatorSelect.value,
                    value: parseFloat(valueInput.value)
                });
            });

            if (!currentResult) {
                showModal("Aucun résultat à sauvegarder. Résolvez d'abord le problème.", 'ok');
                return;
            }

            const problem = {
                objectiveName,
                objectiveFunction,
                optimizationType,
                constraints,
                solution: {
                    variables: currentResult.variables,
                    p: currentResult.p
                }
            };

            let savedProblems = JSON.parse(localStorage.getItem('savedProblems')) || [];
            savedProblems.push(problem);
            localStorage.setItem('savedProblems', JSON.stringify(savedProblems));

            showModal("Problème sauvegardé avec succès !", 'ok');
            displaySavedProblems();
        });

        // Fonction pour afficher la liste des problèmes sauvegardés
        function displaySavedProblems() {
            const savedProblemsList = document.getElementById('saved-problems-list');
            savedProblemsList.innerHTML = '';

            const savedProblems = JSON.parse(localStorage.getItem('savedProblems')) || [];
            if (savedProblems.length === 0) {
                savedProblemsList.innerHTML = '<p class="text-gray-600 dark:text-gray-400">Aucun problème sauvegardé pour le moment.</p>';
                return;
            }

            savedProblems.forEach((problem, index) => {
                const problemDiv = document.createElement('div');
                problemDiv.className = 'p-3 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center justify-between shadow-sm border border-gray-200 dark:border-gray-600';
                problemDiv.innerHTML = `
                    <div>
                        <h4 class="font-semibold text-gray-800 dark:text-gray-200">${problem.objectiveName}</h4>
                        <p class="text-sm text-gray-700 dark:text-gray-300">${problem.objectiveFunction}</p>
                        <p class="text-xs text-gray-600 dark:text-gray-400">Type: ${problem.optimizationType === 'max' ? 'Maximisation' : 'Minimisation'}</p>
                    </div>
                    <div class="flex space-x-2">
                        <button class="bg-indigo-500 hover:bg-indigo-600 text-white rounded-full p-2 text-sm"
                            onclick="showModal('Chargement du problème ${problem.objectiveName}', 'ok', () => loadProblem(${index}))">
                            <i class="ph-bold ph-download"></i>
                        </button>
                        <button class="bg-red-500 hover:bg-red-600 text-white rounded-full p-2 text-sm"
                            onclick="showModal('Voulez-vous vraiment supprimer le problème ${problem.objectiveName} ?', 'confirm', () => deleteProblem(${index}))">
                            <i class="ph-bold ph-trash"></i>
                        </button>
                    </div>
                `;
                savedProblemsList.appendChild(problemDiv);
            });
        }

        /**
         * Supprime un problème sauvegardé par son index.
         * @param {number} index - L'index du problème à supprimer.
         */
        function deleteProblem(index) {
            let savedProblems = JSON.parse(localStorage.getItem('savedProblems')) || [];
            savedProblems.splice(index, 1);
            localStorage.setItem('savedProblems', JSON.stringify(savedProblems));
            displaySavedProblems();
            showModal("Problème supprimé avec succès !", 'ok');
        }

        /**
         * Charge un problème sauvegardé dans le formulaire.
         * @param {number} index - L'index du problème à charger.
         */
        function loadProblem(index) {
            const savedProblems = JSON.parse(localStorage.getItem('savedProblems')) || [];
            const problem = savedProblems[index];

            // Remplir les champs avec les valeurs du problème sauvegardé
            document.getElementById('objective-name').value = problem.objectiveName;
            objectiveFunctionInput.value = problem.objectiveFunction;
            document.getElementById('optimization-type').value = problem.optimizationType;

            // Effacer les contraintes actuelles
            constraintsContainer.innerHTML = '';

            // Ajouter les contraintes sauvegardées et mettre à jour les boutons
            problem.constraints.forEach(constraint => {
                handleAddConstraint(); // Ajoute un nouveau groupe avec les classes et boutons par défaut
                const constraintGroups = constraintsContainer.querySelectorAll('.constraint-group');
                const lastGroup = constraintGroups[constraintGroups.length - 1];
                lastGroup.querySelector('.constraint-name').value = constraint.name;
                lastGroup.querySelector('.constraint-expression').value = constraint.expression;
                lastGroup.querySelector('.constraint-operator').value = constraint.operator;
                lastGroup.querySelector('.constraint-value').value = constraint.value;
            });

            // Si le problème n'avait pas de contraintes, assurez-vous qu'il y en a au moins une vide
            if (problem.constraints.length === 0) {
                handleAddConstraint();
            }

            // Afficher la solution si elle est sauvegardée
            if (problem.solution) {
                displaySolution(problem.solution, parseProblem(problem.objectiveFunction, problem.constraints, problem.optimizationType));
                outputSection.classList.remove('hidden');
                // Note: Les tableaux, graphiques et analyses de sensibilité ne sont pas sauvegardés dans le problème
                // Il faudrait les recalculer si on veut les afficher après un chargement.
                // Pour l'instant, on les cache.
                tableauxSection.classList.add('hidden');
                graphSection.classList.add('hidden');
                sensitivitySection.classList.add('hidden');
            }
        }

        // --- Initialisation de la page au chargement du DOM ---
        document.addEventListener('DOMContentLoaded', () => {
            // Applique le thème sauvegardé au chargement de la page
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const modeToggle = document.querySelector('.mode-toggle');
            const icon = modeToggle.querySelector('i');

            if (savedTheme === 'dark') {
                body.classList.add('dark-mode');
                icon.classList.replace('ph-moon', 'ph-sun');
                modeToggle.setAttribute('aria-label', 'Passer en mode clair');
            } else {
                icon.classList.replace('ph-sun', 'ph-moon');
                modeToggle.setAttribute('aria-label', 'Passer en mode sombre');
            }

            // Initialise le premier groupe de contraintes s'il n'y en a pas
            if (constraintsContainer.querySelectorAll('.constraint-group').length === 0) {
                handleAddConstraint();
            } else {
                // Met à jour les boutons pour les contraintes existantes au chargement
                updateConstraintButtons();
            }

            // Charge la liste des problèmes sauvegardés au chargement de la page
            displaySavedProblems();
        });
    </script>
</body>

</html>
