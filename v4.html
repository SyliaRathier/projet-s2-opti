<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Optimisation Simplexe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            margin: auto;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1rem;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .pivot-row {
            background-color: #e0f7fa;
        }

        .pivot-col {
            font-weight: bold;
            color: #007bff;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 2rem;
        }

        #input-section {
            background-color: #fff;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 2rem;
            width: 90%;
            max-width: 600px;
        }

        #input-section label {
            display: block;
            margin-bottom: 0.5rem;
            color: #444;
            font-weight: 500;
        }

        #input-section input[type="text"],
        #input-section textarea,
        #input-section select {
            width: calc(100% - 20px);
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            transition: border-color 0.3s ease;
            font-size: 1rem;
        }

        #input-section input[type="text"]:focus,
        #input-section textarea:focus,
        #input-section select:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        #input-section textarea {
            resize: vertical;
            min-height: 100px;
        }

        #input-section button {
            padding: 0.75rem 1.5rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-size: 1.1rem;
            width: 100%;
        }

        #input-section button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #input-section button:active {
            background-color: #388e3c;
            transform: translateY(0);
        }

        #result-container {
            background-color: #e3f4f1;
            padding: 1.5rem;
            border-radius: 10px;
            margin-top: 2rem;
            width: 90%;
            max-width: 600px;
            border: 1px solid #b0f0d4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        #result-container h3 {
            color: #1a5235;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        #result-container pre {
            color: #006400;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            font-size: 1rem;
        }

        #graph-container {
            width: 100%;
            max-width: 600px;
            margin-top: 2rem;
        }

        @media (max-width: 768px) {
            #input-section {
                width: 95%;
            }

            #result-container {
                width: 95%;
            }
        }

        @media (max-width: 480px) {
            #input-section button {
                font-size: 1rem;
                padding: 0.75rem 1rem;
            }

            #result-container pre {
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <h1>Optimisation Simplexe</h1>

    <div id="input-section">
        <label for="optimization-type">Type d'optimisation :</label>
        <select id="optimization-type">
            <option value="maximize">Maximiser</option>
            <option value="minimize">Minimiser</option>
        </select>

        <label for="objective">Fonction objectif :</label>
        <input type="text" id="objective" value="3x + 2y">

        <label for="constraints">Contraintes :</label>
        <textarea id="constraints" rows="5">x + y >= 4
2x + y >= 5</textarea>

        <button onclick="solve()">Résoudre</button>
    </div>

    <div id="result-container">
        <h3>Résultat :</h3>
        <pre id="result"></pre>
    </div>

    <div id="graph-container"></div>

    <script>
        function parseExpr(expr) {
            let terms = expr.replace(/\s+/g, '').match(/[+-]?\d*\.?\d*[a-z]/gi);
            let coeffs = {};
            for (let t of terms) {
                let [, coef, varName] = t.match(/([+-]?\d*\.?\d*)([a-z])/);
                coef = coef === '' || coef === '+' ? 1 : coef === '-' ? -1 : parseFloat(coef);
                coeffs[varName] = coef;
            }
            return coeffs;
        }

        function extractVars(objective, constraints) {
            const all = [objective, ...constraints].join('');
            return Array.from(new Set(all.match(/[a-z]/gi))).sort();
        }

        function buildTableau(objective, constraints, vars, optimizationType) {
            let tableau = [], rhs = [];
            let numConstraints = constraints.length;
            let numVars = vars.length;
            let numSlackSurplus = 0;
            let numArtificial = 0;

            let constraintTypes = [];
            for (let line of constraints) {
                if (line.includes('<=')) {
                    constraintTypes.push('<=');
                    numSlackSurplus++;
                } else if (line.includes('>=')) {
                    constraintTypes.push('>=');
                    numSlackSurplus++;
                    numArtificial++;
                }
            }

            let totalVars = numVars + numSlackSurplus + numArtificial;

            for (let i = 0; i < numConstraints; i++) {
                let line = constraints[i];
                let [lhs, b] = line.split(/<=|>=/).map(x => x.trim());
                let coeffs = parseExpr(lhs);
                let row = Array(totalVars).fill(0);
                let bVal = parseFloat(b);

                for (let j = 0; j < numVars; j++) {
                    row[j] = coeffs[vars[j]] || 0;
                }

                let slackSurplusIndex = numVars;
                let artificialIndex = numVars + numSlackSurplus;

                if (constraintTypes[i] === '<=') {
                    row[slackSurplusIndex + i] = 1;
                    rhs.push(bVal);
                } else if (constraintTypes[i] === '>=') {
                    row[slackSurplusIndex + i] = -1; // Variable de surplus (négative)
                    row[artificialIndex + i] = 1; // Variable artificielle (positive)
                    rhs.push(bVal);
                }
                tableau.push(row);
            }

            // Ligne de coût initiale
            let objRow = Array(totalVars).fill(0);
            let objCoeffs = parseExpr(objective);
            let M = 1e9; // Un grand nombre

            for (let i = 0; i < numVars; i++) {
                objRow[i] = -(objCoeffs[vars[i]] || 0); // Coefficients pour maximiser -Z
            }

            // Ajustement pour les variables artificielles
            let artificialVarOffset = numVars + numSlackSurplus;
            for (let i = 0; i < numArtificial; i++) {
                objRow[artificialVarOffset + i] = (optimizationType === 'minimize' ? M : -M); // +M pour min, -M pour max
            }

            tableau.push(objRow);
            rhs.push(0);

            return { tableau, rhs, numSlackSurplus, numArtificial }; // Retourner le nombre de variables de surplus et artificielles
        }


        function pivot(tableau, rhs, pivotRow, pivotCol) {
            let pivotValue = tableau[pivotRow][pivotCol];
            if (Math.abs(pivotValue) < 1e-8) {
                throw "Pivot nul ou très petit";
            }

            // Diviser la ligne pivot par le pivot
            for (let i = 0; i < tableau[pivotRow].length; i++) {
                tableau[pivotRow][i] /= pivotValue;
            }
            rhs[pivotRow] /= pivotValue;

            // Soustraire la ligne pivot multipliée par l'élément correspondant des autres lignes
            for (let i = 0; i < tableau.length; i++) {
                if (i !== pivotRow) {
                    let factor = tableau[i][pivotCol];
                    for (let j = 0; j < tableau[i].length; j++) {
                        tableau[i][j] -= factor * tableau[pivotRow][j];
                    }
                    rhs[i] -= factor * rhs[pivotRow];
                }
            }
        }


        function simplex(tableauInitial, rhsInitial) {
            let tableau = JSON.parse(JSON.stringify(tableauInitial)); // Créer une copie pour ne pas modifier l'original
            let rhs = [...rhsInitial];
            let cols = tableau[0].length;
            let rows = tableau.length;
            let history = [{ tableau: JSON.parse(JSON.stringify(tableau)), rhs: [...rhs] }]; // Enregistrer le tableau initial

            while (true) {
                let last = tableau[rows - 1];
                let entering = last.findIndex(x => x < -1e-8);
                if (entering === -1) break;

                let minRatio = Infinity, pivotRow = -1;
                for (let i = 0; i < rows - 1; i++) {
                    if (tableau[i][entering] > 1e-8) {
                        let ratio = rhs[i] / tableau[i][entering];
                        if (ratio < minRatio) {
                            minRatio = ratio;
                            pivotRow = i;
                        }
                    }
                }
                if (pivotRow === -1) throw "Problème non borné";

                pivot(tableau, rhs, pivotRow, entering);
                history.push({ tableau: JSON.parse(JSON.stringify(tableau)), rhs: [...rhs], pivotRow, pivotCol: entering }); // Enregistrer le tableau après le pivot
            }
            return { tableau, rhs, history };
        }

        function solve() {
            let obj = document.getElementById("objective").value;
            let constraints = document.getElementById("constraints").value.trim().split('\n');
            let optimizationType = document.getElementById("optimization-type").value;
            let resultDiv = document.getElementById("result");
            let graphContainer = document.getElementById("graph-container");

            try {
                const vars = extractVars(obj, constraints);
                let { tableau, rhs, numSlackSurplus, numArtificial } = buildTableau(obj, constraints, vars, optimizationType);

                // Afficher le tableau initial pour le débogage
                let outputInitialTable = "<h3>Tableau Initial (Débogage) :</h3><table><tr>";
                let tableauVars = [...vars];
                for (let i = 0; i < numSlackSurplus; i++) {
                    tableauVars.push(`s${i + 1}`);
                }
                for (let i = 0; i < numArtificial; i++) {
                    tableauVars.push(`a${i + 1}`);
                }
                tableauVars.push("-p");
                tableauVars.forEach(v => outputInitialTable += `<th>${v}</th>`);
                outputInitialTable += "<th>RHS</th></tr>";
                tableau.forEach((row, i) => {
                    outputInitialTable += "<tr>";
                    row.forEach(cell => outputInitialTable += `<td>${cell.toFixed(4)}</td>`);
                    outputInitialTable += `<td>${rhs[i] ? rhs[i].toFixed(4) : ''}</td></tr>`;
                });
                outputInitialTable += "</table>";
                resultDiv.innerHTML = outputInitialTable;

                let finalResult = simplex(tableau, rhs);
                let finalTableau = finalResult.tableau;
                let finalRhs = finalResult.rhs;
                let history = finalResult.history;

                let output = "La solution optimale est :\n";
                let values = Array(vars.length).fill(0);
                let fullVars = [...vars, ...Array(numSlackSurplus).fill(0).map((_, i) => `s${i + 1}`), ...Array(numArtificial).fill(0).map((_, i) => `a${i + 1}`)];

                for (let v = 0; v < vars.length; v++) {
                    let found = false;
                    for (let i = 0; i < finalTableau.length - 1; i++) {
                        let count = 0;
                        for (let j = 0; j < finalTableau[0].length - 1; j++) {
                            if (Math.abs(finalTableau[i][j]) < 1e-8) {
                                count++;
                            } else if (Math.abs(finalTableau[i][j] - 1) < 1e-8 && j === v) {
                                values[v] = finalRhs[i];
                                found = true;
                                break;
                            }
                        }
                        if (found) break;
                    }
                    if (!found) {
                        values[v] = 0;
                    }
                }

                for (let i = 0; i < vars.length; i++) {
                    output += `${vars[i]} = ${values[i].toFixed(4)}\n`;
                }

                let z = finalRhs[finalRhs.length - 1];
                if (optimizationType === 'minimize') {
                    z = -z;
                }
                output += `Valeur optimale : ${z.toFixed(4)}\n\n`;
                resultDiv.innerHTML += output;

                // Afficher les étapes du Simplex (avec les noms de variables mis à jour)
                let tableauDiv = document.createElement('div');
                tableauDiv.innerHTML += '<h3>Étapes du Simplexe :</h3>';
                history.forEach((step, index) => {
                    tableauDiv.innerHTML += `<h4>Tableau ${index + 1}:</h4>`;
                    let tbl = document.createElement('table');
                    let headerRow = tbl.insertRow();
                    fullVars.forEach(v => {
                        let th = document.createElement('th');
                        th.textContent = v;
                        headerRow.appendChild(th);
                    });
                    let thRhs = document.createElement('th');
                    thRhs.textContent = 'RHS';
                    headerRow.appendChild(thRhs);

                    step.tableau.forEach((row, i) => {
                        let dataRow = tbl.insertRow();
                        row.forEach(cell => {
                            let td = document.createElement('td');
                            td.textContent = cell.toFixed(4);
                            dataRow.appendChild(td);
                        });
                        let tdRhs = document.createElement('td');
                        tdRhs.textContent = step.rhs[i].toFixed(4);
                        dataRow.appendChild(tdRhs);
                        if (i === step.pivotRow && step.pivotCol !== undefined && index > 0) {
                            dataRow.classList.add('pivot-row');
                            dataRow.cells[step.pivotCol].classList.add('pivot-col');
                        }
                    });
                    tableauDiv.appendChild(tbl);
                    if (step.pivotRow !== undefined && index > 0) {
                        tableauDiv.innerHTML += `<p>Pivot : Ligne ${step.pivotRow + 1}, Colonne <span class="math-inline">\{step\.pivotCol \+ 1\} \(</span>{fullVars[step.pivotCol]})</p>`;
                    }
                });
                resultDiv.appendChild(tableauDiv);

                plotResult(vars, values, z, constraints);

            } catch (err) {
                resultDiv.textContent = "Erreur : " + err;
                graphContainer.innerHTML = '';
            }
        }


        function plotResult(vars, values, optimalValue, constraints) {
            let graphContainer = document.getElementById("graph-container");
            graphContainer.innerHTML = ''; // Clear previous graph

            let traces = [];
            let colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];

            if (vars.length === 2) {
                // 2D Plot
                let solutionTrace = {
                    x: [values[0]],
                    y: [values[1]],
                    mode: 'markers+text',
                    type: 'scatter',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split(/<=|>=/).map(x => x.trim());
                    let inequality = constraint.includes('<=') ? '<=' : '>=';
                    let coeffs = parseExpr(lhs);
                    let xValues = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yValues = [parseFloat(b) / coeffs[vars[1]], 0];

                    if (inequality === '>=') {
                        xValues = xValues.map(x => -x);
                        yValues = yValues.map(y => -y);
                    }

                    let constraintTrace = {
                        x: xValues,
                        y: yValues,
                        mode: 'lines',
                        type: 'scatter',
                        name: `Contrainte ${index + 1}`,
                        line: { color: colors[index % colors.length], width: 2 }
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    xaxis: { title: vars[0] },
                    yaxis: { title: vars[1] },
                    showlegend: true
                };

                Plotly.newPlot(graphContainer, traces, layout);

            } else if (vars.length === 3) {
                // 3D Plot
                let solutionTrace = {
                    x: [values[0]],
                    y: [values[1]],
                    z: [values[2]],
                    mode: 'markers+text',
                    type: 'scatter3d',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints as surfaces
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split(/<=|>=/).map(x => x.trim());
                    let inequality = constraint.includes('<=') ? '<=' : '>=';
                    let coeffs = parseExpr(lhs);
                    let xRange = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yRange = [0, parseFloat(b) / coeffs[vars[1]]];

                    if (inequality === '>=') {
                        xRange = xRange.map(x => -x);
                        yRange = yRange.map(y => -y);
                    }

                    let xValues = [];
                    let yValues = [];
                    let zValues = [];

                    for (let x = xRange[0]; x <= xRange[1]; x += 0.5) {
                        for (let y = yRange[0]; y <= yRange[1]; y += 0.5) {
                            let z = (parseFloat(b) - coeffs[vars[0]] * x - coeffs[vars[1]] * y) / coeffs[vars[2]];
                            if (z >= 0) {
                                xValues.push(x);
                                yValues.push(y);
                                zValues.push(z);
                            }
                        }
                    }

                    // Create a meshgrid for the surface plot
                    let xGrid = [];
                    let yGrid = [];
                    let zGrid = [];
                    let xStep = xRange[1] / 10;
                    let yStep = yRange[1] / 10;

                    for (let x = xRange[0]; x <= xRange[1]; x += xStep) {
                        let xRow = [];
                        let yRow = [];
                        let zRow = [];
                        for (let y = yRange[0]; y <= yRange[1]; y += yStep) {
                            let z = (parseFloat(b) - coeffs[vars[0]] * x - coeffs[vars[1]] * y) / coeffs[vars[2]];
                            if (z >= 0) {
                                xRow.push(x);
                                yRow.push(y);
                                zRow.push(z);
                            }
                        }
                        xGrid.push(xRow);
                        yGrid.push(yRow);
                        zGrid.push(zRow);
                    }

                    let constraintTrace = {
                        x: xGrid,
                        y: yGrid,
                        z: zGrid,
                        type: 'surface',
                        name: `Contrainte ${index + 1}`,
                        opacity: 0.5,
                        colorscale: [[0, colors[index % colors.length]], [1, colors[index % colors.length]]],
                        showscale: false
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    scene: {
                        xaxis: { title: vars[0] },
                        yaxis: { title: vars[1] },
                        zaxis: { title: vars[2] }
                    }
                };

                Plotly.newPlot(graphContainer, traces, layout);
            }
        }
    </script>
</body>

</html>
