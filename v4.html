<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Optimisation Simplexe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Charger la bibliothèque javascript-lp-solver -->
    <script src="https://cdn.jsdelivr.net/npm/javascript-lp-solver@0.4.25/src/solver.js"></script>
    <style>
        :root {
            --background-color: #f8f9fa;
            /* Very Light Gray */
            --text-color: #2d3748;
            /* Dark Gray */
            --input-background: #fff;
            --input-border: #e2e8f0;
            /* Light Gray Border */
            --button-background: #4299e1;
            /* Blue 500 */
            --button-hover: #3182ce;
            /* Blue 600 */
            --button-active: #2b6cb0;
            /* Blue 700 */
            --result-background: #e6f0ff;
            /* Very Light Blue */
            --result-border: #b3d9ff;
            /* Light Blue Border */
            --table-header: #f0f4f8;
            /* Very Light Grayish Blue */
            --pivot-row: #e6f0ff;
            /* Light Cyan */
            --pivot-col: #007bff;
            /* Primary Blue */
            --pivot-row-font: #2d3748;
            /* Dark Gray */
        }

        .dark-mode {
            --background-color: #1a202c;
            /* Gray 900 */
            --text-color: #f7fafc;
            /* Gray 50 */
            --input-background: #2d3748;
            /* Gray 800 */
            --input-border: #4a5568;
            /* Gray 600 */
            --button-background: #667eea;
            /* Indigo 400 */
            --button-hover: #5a67d8;
            /* Indigo 500 */
            --button-active: #4c51bf;
            /* Indigo 600 */
            --result-background: #283149;
            /* Custom Dark */
            --result-border: #3e4c66;
            /* Custom Dark */
            --table-header: #2d3748;
            /* Gray 800 */
            --pivot-row: #2a69ac;
            /* Blue 700 - darker for contrast */
            --pivot-col: #26c9ff;
            /* Blue 300 - lighter for contrast */
            --pivot-row-font: #f7fafc;
            /* Gray 50 */
        }

        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            margin: auto;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1rem;
        }

        th,
        td {
            border: 1px solid #cbd5e0;
            /* Gray 400 */
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: var(--table-header);
            font-weight: 600;
            color: var(--text-color);
        }

        .pivot-row {
            background-color: var(--pivot-row);
            color: var(--pivot-row-font);
        }

        .pivot-col {
            font-weight: bold;
            color: var(--pivot-col);
        }

        h1 {
            text-align: center;
            color: var(--text-color);
            margin-bottom: 2rem;
        }

        #input-section {
            background-color: var(--input-background);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            width: 95%;
            max-width: 600px;
            transition: background-color 0.3s;
        }

        #input-section label {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--text-color);
            font-weight: 500;
        }

        #input-section input[type="text"],
        #input-section textarea,
        #input-section select {
            width: calc(100% - 20px);
            padding: 0.8rem;
            margin-bottom: 1.25rem;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            transition: border-color 0.3s ease;
            font-size: 1rem;
            background-color: var(--input-background);
            color: var(--text-color);
        }

        #input-section input[type="text"]:focus,
        #input-section textarea:focus,
        #input-section select:focus {
            outline: none;
            border-color: var(--button-background);
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.3);
            /* Blue 200 */
        }

        #input-section textarea {
            resize: vertical;
            min-height: 120px;
        }

        #input-section button {
            padding: 0.8rem 1.75rem;
            background-color: var(--button-background);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            font-size: 1.1rem;
            width: 100%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #input-section button:hover {
            background-color: var(--button-hover);
            transform: translateY(-1px);
        }

        #input-section button:active {
            background-color: var(--button-active);
            transform: translateY(0);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.15);
        }

        #result-container {
            background-color: var(--input-background);
            padding: 1.75rem;
            border-radius: 8px;
            margin-top: 2rem;
            width: 95%;
            max-width: 600px;
            /*border: 1px solid var(--result-border);*/
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            transition: background-color 0.3s, border-color 0.3s;
        }

        #result-container h3 {
            color: var(--text-color);
            margin-bottom: 1.25rem;
            font-size: 1.3rem;
            font-weight: 600;
        }

        #result-container pre {
            color: var(--text-color);
            font-family: 'Menlo', monospace;
            white-space: pre-wrap;
            line-height: 1.6;
            font-size: 1rem;
        }

        #graph-container {
            width: 100%;
            max-width: 600px;
            margin-top: 2rem;
        }

        .mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--button-background);
            color: white;
            border: none;
            border-radius: 50%;
            /* Make it a circle */
            padding: 0.6rem;
            /* Ajuster le padding pour l'icône */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease;
            /* Ajout de la transition pour la rotation */
            font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            /* Augmentation de l'ombre */
            line-height: 0;
            /* Supprimer la hauteur de ligne pour centrer verticalement l'icône */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            /* Définir une largeur fixe pour le bouton icône */
            height: 2.5rem;
            /* Définir une hauteur fixe pour le bouton icône */
        }

        .mode-toggle:hover {
            background-color: var(--button-hover);
            transform: translateY(-2px) scale(1.1);
            /* Légère translation et mise à l'échelle au survol */
        }

        .mode-toggle:active {
            background-color: var(--button-active);
            transform: translateY(0) scale(0.9);
            /* Légère réduction à l'activation */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
            /* Réduction de l'ombre à l'activation */
        }

        .mode-toggle i {
            font-size: 1.5rem;
            /* Ajuster la taille de l'icône */
            color: white;
            transition: transform 0.3s ease;
            /* Smooth transition for icon rotation */
        }

        .dark-mode .mode-toggle i {
            transform: rotate(30deg);
            /* Rotate the sun icon in dark mode */
        }

        @media (max-width: 768px) {

            #input-section,
            #result-container,
            #graph-container {
                width: 98%;
            }
        }

        @media (max-width: 480px) {
            #input-section button {
                font-size: 1rem;
                padding: 0.8rem 1.2rem;
            }

            #result-container pre {
                font-size: 0.9rem;
            }

            .mode-toggle {
                top: 10px;
                right: 10px;
                padding: 0.5rem;
                font-size: 0.8rem;
                width: 2.25rem;
                height: 2.25rem;
            }

            .mode-toggle i {
                font-size: 1.25rem;
            }
        }
    </style>
</head>

<body>
    <button class="mode-toggle" onclick="toggleMode()">
        <i class="fas fa-moon"></i>
    </button>

    <h1>Optimisation Simplexe</h1>

    <div id="input-section">
        <label for="optimization-type">Type d'optimisation :</label>
        <select id="optimization-type">
            <option value="maximize">Maximiser</option>
            <option value="minimize">Minimiser</option>
        </select>

        <label for="objective">Fonction objectif :</label>
        <input type="text" id="objective" value="3x + 2y" placeholder="Ex: 3x + 2y (variables séparées par des '+')">

        <label for="constraints">Contraintes :</label>
        <textarea id="constraints" rows="5"
            placeholder="Ex: x + y >= 4&#10;2x + y <= 5 (une contrainte par ligne, utilisez >=, <= ou =)">x + y >= 4
2x + y >= 5</textarea>

        <button onclick="solve()">Résoudre</button>
    </div>

    <div id="result-container">
        <h3>Résultat :</h3>
        <pre id="result"></pre>
    </div>

    <div id="graph-container"></div>

    <script>
        function toggleMode() {
            const body = document.body;
            const modeToggle = document.querySelector('.mode-toggle');
            const moonIcon = document.querySelector('.mode-toggle i');

            // Toggle the dark mode class on the body
            body.classList.toggle('dark-mode');

            // Check if dark mode is active
            const isDarkMode = body.classList.contains('dark-mode');

            // Update the icon based on the current mode
            if (isDarkMode) {
                moonIcon.classList.remove('fa-moon');
                moonIcon.classList.add('fa-sun');
            } else {
                moonIcon.classList.remove('fa-sun');
                moonIcon.classList.add('fa-moon');
            }
        }

        function parseExpr(expr) {
            let terms = expr.replace(/\s+/g, '').match(/[+-]?\d*\.?\d*[a-z]/gi);
            let coeffs = {};
            for (let t of terms) {
                let [, coef, varName] = t.match(/([+-]?\d*\.?\d*)([a-z])/);
                coef = coef === '' || coef === '+' ? 1 : coef === '-' ? -1 : parseFloat(coef);
                coeffs[varName] = coef;
            }
            return coeffs;
        }

        function extractVars(objective, constraints) {
            const all = [objective, ...constraints].join('');
            return Array.from(new Set(all.match(/[a-z]/gi))).sort();
        }

        function solve() {
            let obj = document.getElementById("objective").value;
            let constraints = document.getElementById("constraints").value.trim().split('\n');
            let optimizationType = document.getElementById("optimization-type").value;
            let resultDiv = document.getElementById("result");
            let graphContainer = document.getElementById("graph-container");

            try {
                const vars = extractVars(obj, constraints);
                let model = {
                    optimize: obj,
                    opType: optimizationType,
                    constraints: {},
                    variables: {}
                };

                // Parse objective
                let objCoeffs = parseExpr(obj);
                for (let varName in objCoeffs) {
                    model.variables[varName] = { [optimizationType]: objCoeffs[varName] };
                }

                // Parse constraints
                constraints.forEach((constraint, index) => {
                    let [lhs, rhs] = constraint.split(/<=|>=|=/).map(x => x.trim());
                    let inequality = constraint.includes('<=') ? '<=' : constraint.includes('>=') ? '>=' : '=';
                    let coeffs = parseExpr(lhs);
                    let constraintName = `constraint${index + 1}`;

                    model.constraints[constraintName] = {
                        [inequality === '<=' ? 'max' : inequality === '>=' ? 'min' : 'equal']: parseFloat(rhs)
                    };

                    for (let varName in coeffs) {
                        model.constraints[constraintName][varName] = coeffs[varName];
                    }
                });

                // Solve the model
                let result = solver.Solve(model);

                // Display the result
                let output = "La solution optimale est :\n";
                for (let varName in result) {
                    if (varName !== 'feasible' && varName !== 'result') {
                        output += `${varName} = ${result[varName]}\n`;
                    }
                }
                output += `Valeur optimale : ${result.result}\n\n`;
                resultDiv.innerHTML = output;

                // Plot the result
                plotResult(vars, result, result.result, constraints);

            } catch (err) {
                resultDiv.textContent = "Erreur : " + err;
                graphContainer.innerHTML = '';
            }
        }

        function plotResult(vars, values, optimalValue, constraints) {
            let graphContainer = document.getElementById("graph-container");
            graphContainer.innerHTML = ''; // Clear previous graph

            let traces = [];
            let colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];

            if (vars.length === 2) {
                // 2D Plot
                let solutionTrace = {
                    x: [values[vars[0]]],
                    y: [values[vars[1]]],
                    mode: 'markers+text',
                    type: 'scatter',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split(/<=|>=/).map(x => x.trim());
                    let inequality = constraint.includes('<=') ? '<=' : '>=';
                    let coeffs = parseExpr(lhs);
                    let xValues = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yValues = [parseFloat(b) / coeffs[vars[1]], 0];

                    if (inequality === '>=') {
                        xValues = xValues.map(x => -x);
                        yValues = yValues.map(y => -y);
                    }

                    let constraintTrace = {
                        x: xValues,
                        y: yValues,
                        mode: 'lines',
                        type: 'scatter',
                        name: `Contrainte ${index + 1}`,
                        line: { color: colors[index % colors.length], width: 2 }
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    xaxis: { title: vars[0] },
                    yaxis: { title: vars[1] },
                    showlegend: true
                };

                Plotly.newPlot(graphContainer, traces, layout);

            } else if (vars.length === 3) {
                // 3D Plot
                let solutionTrace = {
                    x: [values[vars[0]]],
                    y: [values[vars[1]]],
                    z: [values[vars[2]]],
                    mode: 'markers+text',
                    type: 'scatter3d',
                    name: 'Solution optimale',
                    text: [`Valeur optimale : ${optimalValue.toFixed(4)}`],
                    marker: { size: 12, color: 'red' },
                    textposition: 'top center'
                };

                traces.push(solutionTrace);

                // Add constraints as surfaces
                constraints.forEach((constraint, index) => {
                    let [lhs, b] = constraint.split(/<=|>=/).map(x => x.trim());
                    let inequality = constraint.includes('<=') ? '<=' : '>=';
                    let coeffs = parseExpr(lhs);
                    let xRange = [0, parseFloat(b) / coeffs[vars[0]]];
                    let yRange = [0, parseFloat(b) / coeffs[vars[1]]];

                    if (inequality === '>=') {
                        xRange = xRange.map(x => -x);
                        yRange = yRange.map(y => -y);
                    }

                    let xValues = [];
                    let yValues = [];
                    let zValues = [];

                    for (let x = xRange[0]; x <= xRange[1]; x += 0.5) {
                        for (let y = yRange[0]; y <= yRange[1]; y += 0.5) {
                            let z = (parseFloat(b) - coeffs[vars[0]] * x - coeffs[vars[1]] * y) / coeffs[vars[2]];
                            if (z >= 0) {
                                xValues.push(x);
                                yValues.push(y);
                                zValues.push(z);
                            }
                        }
                    }

                    // Create a meshgrid for the surface plot
                    let xGrid = [];
                    let yGrid = [];
                    let zGrid = [];
                    let xStep = xRange[1] / 10;
                    let yStep = yRange[1] / 10;

                    for (let x = xRange[0]; x <= xRange[1]; x += xStep) {
                        let xRow = [];
                        let yRow = [];
                        let zRow = [];
                        for (let y = yRange[0]; y <= yRange[1]; y += yStep) {
                            let z = (parseFloat(b) - coeffs[vars[0]] * x - coeffs[vars[1]] * y) / coeffs[vars[2]];
                            if (z >= 0) {
                                xRow.push(x);
                                yRow.push(y);
                                zRow.push(z);
                            }
                        }
                        xGrid.push(xRow);
                        yGrid.push(yRow);
                        zGrid.push(zRow);
                    }

                    let constraintTrace = {
                        x: xGrid,
                        y: yGrid,
                        z: zGrid,
                        type: 'surface',
                        name: `Contrainte ${index + 1}`,
                        opacity: 0.5,
                        colorscale: [[0, colors[index % colors.length]], [1, colors[index % colors.length]]],
                        showscale: false
                    };

                    traces.push(constraintTrace);
                });

                let layout = {
                    title: 'Solution optimale avec contraintes',
                    scene: {
                        xaxis: { title: vars[0] },
                        yaxis: { title: vars[1] },
                        zaxis: { title: vars[2] }
                    }
                };

                Plotly.newPlot(graphContainer, traces, layout);
            }
        }
    </script>
</body>

</html>
