<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solveur d'optimisation linéaire</title>
    <script src="https://unpkg.com/javascript-lp-solver/prod/solver.js"></script>
    <!-- https://www.npmjs.com/package/javascript-lp-solver -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        label {
            font-weight: bold;
        }

        input,
        select,
        textarea {
            display: block;
            width: 100%;
            margin-top: 5px;
            margin-bottom: 15px;
            padding: 10px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 15px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        #output {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>

    <h1>Solveur d'optimisation linéaire</h1>

    <div id="problem-setup">
        <h2>Définir le problème</h2>

        <label for="opType">Type d'optimisation :</label>
        <select id="opType">
            <option value="max">Maximiser</option>
            <option value="min">Minimiser</option>
        </select>

        <label for="objective">Fonction objectif (ex: 5x + 3y):</label>
        <input id="objective" type="text" placeholder="Ex: 5x + 3y" value="4x + 3y + 2z" />

        <label for="constraints">Contraintes (une par ligne, ex: 2x + y <= 10):</label>
                <textarea id="constraints" rows="5" placeholder="Ex:&#10;2x + y <= 10&#10;x + y >= 5">2x + y + 2z <= 8
3x + 2y + z <= 8</textarea>

                <button onclick="solveProblem()">Résoudre</button>
    </div>

    <div id="results">
        <h2>Résultats</h2>
        <pre id="output"></pre>
    </div>

    <script>
        function parseExpression(expr) {
            const terms = expr.match(/([+-]?\s*\d*\.?\d*\s*[a-zA-Z]+)/g);
            const obj = {};
            if (!terms) return obj;

            terms.forEach(term => {
                // Nettoyer le terme : enlever les espaces
                term = term.replace(/\s+/g, '');

                // Séparer coefficient et variable
                const match = term.match(/^([+-]?\d*\.?\d*)([a-zA-Z]+)$/);
                if (!match) return; // ignorer les termes invalides

                let [, coeff, variable] = match;

                // Gestion du coefficient vide, "+" ou "-"
                if (coeff === "" || coeff === "+") coeff = 1;
                else if (coeff === "-") coeff = -1;
                else coeff = parseFloat(coeff);

                obj[variable] = coeff;
            });
            console.log(obj);
            return obj;
        }


        function solveProblem() {
            const opType = document.getElementById('opType').value;
            const objectiveExpr = document.getElementById('objective').value;
            const constraintsText = document.getElementById('constraints').value.trim();

            const model = {
                optimize: "profit",
                opType: opType,
                constraints: {},
                variables: {},
            };

            // Analyse la fonction objectif
            const objParsed = parseExpression(objectiveExpr);

            // Ajoute chaque variable avec son coefficient de profit
            for (let variable in objParsed) {
                if (!model.variables[variable]) model.variables[variable] = {};
                model.variables[variable]["profit"] = objParsed[variable];
            }

            // Analyse les contraintes
            const lines = constraintsText.split('\n');
            lines.forEach((line, index) => {
                const match = line.match(/(.+?)(<=|>=|=)(.+)/);
                if (!match) return;

                const [_, lhs, operator, rhs] = match.map(e => e.trim());
                const lhsParsed = parseExpression(lhs);
                const rhsValue = parseFloat(rhs);
                const constraintName = `constraint${index + 1}`;

                // Ajoute la contrainte dans l'objet constraints
                model.constraints[constraintName] = {};
                if (operator === "<=") model.constraints[constraintName].max = rhsValue;
                else if (operator === ">=") model.constraints[constraintName].min = rhsValue;
                else if (operator === "=") model.constraints[constraintName].equal = rhsValue;

                // Pour chaque variable de la contrainte, on l’ajoute dans model.variables
                for (let variable in lhsParsed) {
                    if (!model.variables[variable]) model.variables[variable] = {};
                    model.variables[variable][constraintName] = lhsParsed[variable];
                }
            });

            console.log(model);

            try {
                const result = solver.Solve(model);
                document.getElementById('output').textContent = JSON.stringify(result, null, 2);
            } catch (error) {
                document.getElementById('output').textContent = "Erreur: " + error.message;
            }
        }

    </script>
</body>

</html>

<!-- 
{
    "optimize": "profit",
    "opType": "max",
    "constraints": {
        "constraint1": {"max": 8},
        "constraint2": {"max": 8}
    }, 
    "variables": {
        "x": {
            "profit": 4,
            "constraint1": 2,
            "constraint2": 3
        },
        "y": {
            "profit": 3,
            "constraint1": 1,
            "constraint2": 2
        },
        "z": {
            "profit": 2,
            "constraint1": 2,
            "constraint2": 1
        }
    }
}
-->
